# 面向对象编程

## 设计模式

### 创建型

单例模式、工厂模式、builder模式、原型模式

### 结构型

代理模式、桥接模式、装饰者模式、适配器模式、门面模式、组合模式、享元模式

### 行为型

观察者模式、策略模式、状态模式、模板方法模式、责任链模式、解释器模式、中介者模式、备忘录模式、迭代器模式、访问者模式

### 单例模式

保证程序中实例只有一个

* 懒汉模式，双重检测
* 恶汉模式

不太好用面向对象编程的特性

### 工厂模式

* 简单工厂：根据参数创建同类对象
* 工厂方法：每一个对象的创建有各自的工厂创建，这些工厂又由他们的工厂创建
* 抽象工厂：同一个维度的不同类对象都由一个工厂创建

工厂模式解耦了对象的创建和使用，把对象创建的复杂度封装了起来

对象的创建不太复杂的时候用简单工厂，对象的创建很复杂的时候用工厂方法，同个维度的工厂太多的时候用抽象工厂

### builder模式

通过设置不同的可选参数，订制化的创建复杂对象。反之构造方法参数过多以及数量多，也能解决set方法导致的对象无效化，和参数校验的难题

Android中dialog有使用，okhttp有使用

### 原型模式

创建对象不是通过new，而是通过已有的对象原型，拷贝创建

对象的创建成本较大，且一个类的不同对象之间的差异不大，可以用原型模式通过拷贝创建对象

### 代理模式

扩展一个类的非业务型业务可以使用代理模式对源代码无侵入式的扩展，如加日志，权限拦截等

如果原始类不是我们开发的，可以通过继承来实现代理模式

动态代理：动态的创建原始类的代理对象

### 桥接模式

一个类存在两个或对个独立变化的维度，我们可以通过组合的方式，让这两个维度可以独立扩展，通过组合的方式代替集成，来防止类的集成爆炸

### 适配器模式

如果一个类的接口不满足现有需求，可以通过适配器将这个类的接口转化为现在所需要的

华为播放器项目就是见pp视频的oneplayer转换成华为的接口

### 装饰者模式

对一个类原有的功能进行增强，这些增强可以随意组合

java的io相关用到了

### 享元模式

复用对象节省内存

Android中消息机制中的Message#obtain就是用的此模式，弹幕的弹幕对象也可以用这个

### 门面模式

封装复杂的内部实现，提供一个简单的对外入口

我们oneplayer sdk就是此模式

### 组合模式

类的调用逻辑呈现树状结构可以考虑使用此模式

如Android中view的绘制流程

### 观察者模式

解耦被观察者和观察者。被观察者发出消息，观察者可以接受到消息并处理

rxjava

### 策略模式

一个目的可以由多个策略完成，那么这些策略可以被封装起来，这些策略可以替换使用。

此模式可以解决if-else问题

定义一系列算法类，将每个算法封装起来，让他们可以互相替换

* 避免冗长的if-else和switch
* 提供框架的扩展点

### 状态模式

随着状态转移，状态改变。这些状态可以被封装起来

Android wifi功能用到了

一般用来实现状态机。状态机的实现方式有三种。

* 分支逻辑发
* 查表发
* 状态模式

### 责任链模式

通过链式的处理完成某项功能

okhttp中的各种intercept

多个处理器处理同一个请求

* 过滤器
* 拦截器

### 模板方法

**算法骨架**，特定的流程可以分为指定的几个步骤，这些步骤可以定义成模板交由子类来实现

### 迭代器模式

遍历的操作由专门的迭代器类处理，解耦遍历和其他业务。也叫**游标模式**

### 解释器模式

对某些字符做相应解释

为某个语言定义他的语法，并定义一个解释器来处理这个语法

### 访问者模式

对一组数据进行访问处理的模式

允许一个或者多个操作应用到一组对象上，解耦操作和对象本身

### 中介者模式

如果类之间的交互错综复杂，形成多对多的关系，那么可以用中介模式转换成中介者对多的情况

坏处就是终结者作为上帝类，会变得很庞大

### 备忘录模式

某些状态需要保存，以便后续恢复，可以考虑备忘录模式

如android中的onSaveInstance

也叫快照模式，捕获几个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态

### 命令模式

可以抽象出一些指令，接受到某些指令的时候就执行这些指令类中的方法。其实就是想实现把方法作为参数传递。

早期的图形化界面需要使用此模式

函数封装成对象，如撤销重做命令



